<h2><a href=https://www.codewars.com/kata/585894545a8a07255e0002f1/train/java target="_blank">Screen Locking Patterns</a></h2><h3>3 kyu</h3><h2 id="screen-locking-patterns">Screen Locking Patterns</h2><p>You might already be familiar with many smartphones that allow you to use a geometric pattern as a security measure. To unlock the device, you need to connect a sequence of dots/points in a grid by swiping your finger <strong>without lifting it</strong> as you trace the pattern through the screen.</p><p>The image below has an example pattern of 7 dots/points: (A -&gt; B -&gt; I -&gt; E -&gt; D -&gt; G -&gt; C).</p><p><img alt="lock_example.png" src="https://i.imgur.com/zmPNYdv.png"></p><p>For this kata, your job is to implement a function that returns <strong>the number of possible patterns starting from a given first point, that have a given length</strong>. </p><p>More specifically, for a function <code>countPatternsFrom(firstPoint, length)</code>, the parameter <code>firstPoint</code> is a single-character string corresponding to the point in the grid (e.g.: <code>'A'</code>) where your patterns start, and the parameter <code>length</code> is an integer indicating the number of points (length) every pattern must have.</p><p>For example, <code>countPatternsFrom("C", 2)</code>, should return the number of patterns starting from <code>'C'</code> that have <code>2</code> two points. The return value in this case would be <code>5</code>, because there are 5 possible patterns:</p><p>(C -&gt; B), (C -&gt; D), (C -&gt; E), (C -&gt; F) and (C -&gt; H).</p><p>Bear in mind that this kata requires returning the <strong>number</strong> of patterns, <strong>not the patterns themselves</strong>, so you only need to count them. Also, <strong>the name of the function might be different depending on the programming language used</strong>, but the idea remains the same.</p><h2 id="rules">Rules</h2><ol><li>In a pattern, the dots/points <strong>cannot be repeated</strong>: they can only be used once, at most.</li><li>In a pattern, any two subsequent dots/points can only be connected with <strong>direct straight lines</strong> in either of these ways:</li><li><strong>Horizontally:</strong> like (A -&gt; B) in the example pattern image.</li><li><strong>Vertically:</strong> like (D -&gt; G) in the example pattern image.</li><li><strong>Diagonally:</strong> like (I -&gt; E), <em>as well as</em> (B -&gt; I), in the example pattern image.</li><li><strong>Passing over a point between them that has already been 'used':</strong> like (G -&gt; C) passing over E, in the example pattern image. This is the trickiest rule. Normally, you wouldn't be able to connect G to C, because E is between them, <strong>however</strong> when E has already been used as part the pattern you are tracing, you <strong>can</strong> connect G to C <strong>passing over E</strong>, because E is <strong>ignored</strong>, as it was already used once.</li></ol><p><br>The sample tests have some examples of the number of combinations for some cases to help you check your code.</p><p><strong>Haskell Note:</strong> A data type <code>Vertex</code> is provided in place of the single-character strings. See the solution setup code for more details.</p><p><strong>Fun fact:</strong></p><p>In case you're wondering out of curiosity, for the Android lock screen, the valid patterns must have between 4 and 9 dots/points. There are 389112 possible valid patterns in total; that is, patterns with a length between 4 and 9 dots/points.</p>